/*
 * sha512.c
 *
 * This file is part of BloodHorn and is licensed under the BSD License.
 * See the root of the repository for license details.
 */

#include \"crypto.h\"\r\n#include <string.h>\r\n\r\n// SHA-512 constants\r\nstatic const uint64_t sha512_k[80] = {\r\n    0x428a2f98d728ae22ULL, 0x7137449123ef65cdULL, 0xb5c0fbcfec4d3b2fULL, 0xe9b5dba58189dbbcULL,\r\n    0x3956c25bf348b538ULL, 0x59f111f1b605d019ULL, 0x923f82a4af194f9bULL, 0xab1c5ed5da6d8118ULL,\r\n    0xd807aa98a3030242ULL, 0x12835b0145706fbeULL, 0x243185be4ee4b28cULL, 0x550c7dc3d5ffb4e2ULL,\r\n    0x72be5d74f27b896fULL, 0x80deb1fe3b1696b1ULL, 0x9bdc06a725c71235ULL, 0xc19bf174cf692694ULL,\r\n    0xe49b69c19ef14ad2ULL, 0xefbe4786384f25e3ULL, 0x0fc19dc68b8cd5b5ULL, 0x240ca1cc77ac9c65ULL,\r\n    0x2de92c6f592b0275ULL, 0x4a7484aa6ea6e483ULL, 0x5cb0a9dcbd41fbd4ULL, 0x76f988da831153b5ULL,\r\n    0x983e5152ee66dfabULL, 0xa831c66d2db43210ULL, 0xb00327c898fb213fULL, 0xbf597fc7beef0ee4ULL,\r\n    0xc6e00bf33da88fc2ULL, 0xd5a79147930aa725ULL, 0x06ca6351e003826fULL, 0x142929670a0e6e70ULL,\r\n    0x27b70a8546d22ffcULL, 0x2e1b21385c26c926ULL, 0x4d2c6dfc5ac42aedULL, 0x53380d139d95b3dfULL,\r\n    0x650a73548baf63deULL, 0x766a0abb3c77b2a8ULL, 0x81c2c92e47edaee6ULL, 0x92722c851482353bULL,\r\n    0xa2bfe8a14cf10364ULL, 0xa81a664bbc423001ULL, 0xc24b8b70d0f89791ULL, 0xc76c51a30654be30ULL,\r\n    0xd192e819d6ef5218ULL, 0xd69906245565a910ULL, 0xf40e35855771202aULL, 0x106aa07032bbd1b8ULL,\r\n    0x19a4c116b8d2d0c8ULL, 0x1e376c085141ab53ULL, 0x2748774cdf8eeb99ULL, 0x34b0bcb5e19b48a8ULL,\r\n    0x391c0cb3c5c95a63ULL, 0x4ed8aa4ae3418acbULL, 0x5b9cca4f7763e373ULL, 0x682e6ff3d6b2b8a3ULL,\r\n    0x748f82ee5defb2fcULL, 0x78a5636f43172f60ULL, 0x84c87814a1f0ab72ULL, 0x8cc702081a6439ecULL,\r\n    0x90befffa23631e28ULL, 0xa4506cebde82bde9ULL, 0xbef9a3f7b2c67915ULL, 0xc67178f2e372532bULL,\r\n    0xca273eceea26619cULL, 0xd186b8c721c0c207ULL, 0xeada7dd6cde0eb1eULL, 0xf57d4f7fee6ed178ULL,\r\n    0x06f067aa72176fbaULL, 0x0a637dc5a2c898a6ULL, 0x113f9804bef90daeULL, 0x1b710b35131c471bULL,\r\n    0x28db77f523047d84ULL, 0x32caab7b40c72493ULL, 0x3c9ebe0a15c9bebcULL, 0x431d67c49c100d4cULL,\r\n    0x4cc5d4becb3e42b6ULL, 0x597f299cfc657e2aULL, 0x5fcb6fab3ad6faecULL, 0x6c44198c4a475817ULL\r\n};\r\n\r\nstatic const uint64_t sha512_h0[8] = {\r\n    0x6a09e667f3bcc908ULL, 0xbb67ae8584caa73bULL, 0x3c6ef372fe94f82bULL, 0xa54ff53a5f1d36f1ULL,\r\n    0x510e527fade682d1ULL, 0x9b05688c2b3e6c1fULL, 0x1f83d9abfb41bd6bULL, 0x5be0cd19137e2179ULL\r\n};\r\n\r\nstatic uint64_t rotr64(uint64_t x, int n) {\r\n    return (x >> n) | (x << (64 - n));\r\n}\r\n\r\nstatic uint64_t ch64(uint64_t x, uint64_t y, uint64_t z) {\r\n    return (x & y) ^ (~x & z);\r\n}\r\n\r\nstatic uint64_t maj64(uint64_t x, uint64_t y, uint64_t z) {\r\n    return (x & y) ^ (x & z) ^ (y & z);\r\n}\r\n\r\nstatic uint64_t sigma0_512(uint64_t x) {\r\n    return rotr64(x, 28) ^ rotr64(x, 34) ^ rotr64(x, 39);\r\n}\r\n\r\nstatic uint64_t sigma1_512(uint64_t x) {\r\n    return rotr64(x, 14) ^ rotr64(x, 18) ^ rotr64(x, 41);\r\n}\r\n\r\nstatic uint64_t gamma0_512(uint64_t x) {\r\n    return rotr64(x, 1) ^ rotr64(x, 8) ^ (x >> 7);\r\n}\r\n\r\nstatic uint64_t gamma1_512(uint64_t x) {\r\n    return rotr64(x, 19) ^ rotr64(x, 61) ^ (x >> 6);\r\n}\r\n\r\nint crypto_sha512_init(crypto_sha512_ctx_t* ctx) {\r\n    if (!ctx) return CRYPTO_ERROR_INVALID_PARAM;\r\n    \r\n    memcpy(ctx->h, sha512_h0, sizeof(sha512_h0));\r\n    ctx->len = 0;\r\n    ctx->buf_len = 0;\r\n    memset(ctx->buf, 0, sizeof(ctx->buf));\r\n    \r\n    return CRYPTO_SUCCESS;\r\n}\r\n\r\nint crypto_sha512_update(crypto_sha512_ctx_t* ctx, const uint8_t* data, uint32_t len) {\r\n    if (!ctx || !data) return CRYPTO_ERROR_INVALID_PARAM;\r\n    \r\n    ctx->len += len;\r\n    \r\n    while (len > 0) {\r\n        uint32_t chunk_size = (ctx->buf_len + len > 128) ? (128 - ctx->buf_len) : len;\r\n        memcpy(ctx->buf + ctx->buf_len, data, chunk_size);\r\n        ctx->buf_len += chunk_size;\r\n        data += chunk_size;\r\n        len -= chunk_size;\r\n        \r\n        if (ctx->buf_len == 128) {\r\n            // Process block\r\n            uint64_t w[80];\r\n            \r\n            // Prepare message schedule\r\n            for (int i = 0; i < 16; i++) {\r\n                w[i] = ((uint64_t)ctx->buf[i*8] << 56) | ((uint64_t)ctx->buf[i*8+1] << 48) |\r\n                       ((uint64_t)ctx->buf[i*8+2] << 40) | ((uint64_t)ctx->buf[i*8+3] << 32) |\r\n                       ((uint64_t)ctx->buf[i*8+4] << 24) | ((uint64_t)ctx->buf[i*8+5] << 16) |\r\n                       ((uint64_t)ctx->buf[i*8+6] << 8) | ((uint64_t)ctx->buf[i*8+7]);\r\n            }\r\n            \r\n            for (int i = 16; i < 80; i++) {\r\n                w[i] = gamma1_512(w[i-2]) + w[i-7] + gamma0_512(w[i-15]) + w[i-16];\r\n            }\r\n            \r\n            // Initialize working variables\r\n            uint64_t a = ctx->h[0], b = ctx->h[1], c = ctx->h[2], d = ctx->h[3];\r\n            uint64_t e = ctx->h[4], f = ctx->h[5], g = ctx->h[6], h = ctx->h[7];\r\n            \r\n            // Main loop\r\n            for (int i = 0; i < 80; i++) {\r\n                uint64_t temp1 = h + sigma1_512(e) + ch64(e, f, g) + sha512_k[i] + w[i];\r\n                uint64_t temp2 = sigma0_512(a) + maj64(a, b, c);\r\n                h = g; g = f; f = e; e = d + temp1;\r\n                d = c; c = b; b = a; a = temp1 + temp2;\r\n            }\r\n            \r\n            // Add compressed chunk to current hash value\r\n            ctx->h[0] += a; ctx->h[1] += b; ctx->h[2] += c; ctx->h[3] += d;\r\n            ctx->h[4] += e; ctx->h[5] += f; ctx->h[6] += g; ctx->h[7] += h;\r\n            \r\n            ctx->buf_len = 0;\r\n        }\r\n    }\r\n    \r\n    return CRYPTO_SUCCESS;\r\n}\r\n\r\nint crypto_sha512_final(crypto_sha512_ctx_t* ctx, uint8_t* hash) {\r\n    if (!ctx || !hash) return CRYPTO_ERROR_INVALID_PARAM;\r\n    \r\n    // Pre-processing: adding padding bits\r\n    uint64_t msg_len = ctx->len;\r\n    uint64_t bit_len = msg_len * 8;\r\n    \r\n    // Append '1' bit\r\n    ctx->buf[ctx->buf_len++] = 0x80;\r\n    \r\n    // Append '0' bits until message length â‰¡ 896 (mod 1024)\r\n    while (ctx->buf_len % 128 != 112) {\r\n        if (ctx->buf_len == 128) {\r\n            crypto_sha512_update(ctx, ctx->buf, 128);\r\n            ctx->buf_len = 0;\r\n        }\r\n        ctx->buf[ctx->buf_len++] = 0x00;\r\n    }\r\n    \r\n    // Append original length in bits as 128-bit big-endian integer\r\n    for (int i = 0; i < 8; i++) {\r\n        ctx->buf[ctx->buf_len++] = 0; // High 64 bits are 0\r\n    }\r\n    for (int i = 7; i >= 0; i--) {\r\n        ctx->buf[ctx->buf_len++] = (bit_len >> (i * 8)) & 0xFF;\r\n    }\r\n    \r\n    // Process final block\r\n    crypto_sha512_update(ctx, ctx->buf, ctx->buf_len);\r\n    \r\n    // Produce final hash value\r\n    for (int i = 0; i < 8; i++) {\r\n        for (int j = 7; j >= 0; j--) {\r\n            hash[i*8 + (7-j)] = (ctx->h[i] >> (j * 8)) & 0xFF;\r\n        }\r\n    }\r\n    \r\n    return CRYPTO_SUCCESS;\r\n}\r\n\r\nvoid sha512_hash(const uint8_t* data, uint32_t len, uint8_t* hash) {\r\n    crypto_sha512_ctx_t ctx;\r\n    crypto_sha512_init(&ctx);\r\n    crypto_sha512_update(&ctx, data, len);\r\n    crypto_sha512_final(&ctx, hash);\r\n    crypto_zeroize_context(&ctx, sizeof(ctx));\r\n}\r\n
